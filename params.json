{"name":"Scratch Extensions","tagline":"Extensions for Scratch 2.0","body":"# Writing Extensions for Scratch 2.0\r\n\r\nWriting a Javascript extension for Scratch 2.0 starts with some boilerplate code, which looks like the following:\r\n\r\n```javascript\r\nnew (function() {\r\n    var ext = this;\r\n\r\n    // Cleanup function when the extension is unloaded\r\n    ext._shutdown = function() {};\r\n\r\n    // Status reporting code\r\n    // Use this to report missing hardware, plugin or unsupported browser\r\n    ext._getStatus = function() {\r\n        return {status: 2, msg: 'Ready'};\r\n    };\r\n\r\n    // Block and block menu descriptions\r\n    var descriptor = {\r\n        blocks: [\r\n        ]\r\n    };\r\n\r\n    // Register the extension\r\n    ScratchExtensions.register('Sample extension', descriptor, ext);\r\n})();\r\n```\r\n\r\n## Adding Blocks\r\n\r\nAn extension may define a number of blocks, of different types (e.g. a command block, or a hat block, or a reporter block). Blocks can take in parameters.\r\n\r\n### Command blocks\r\n\r\nTo add a simple _command_ block, there needs to be an entry in the ``descriptors.blocks`` list, and a corresponding function for it. The simplest block possible is shown below (it does nothing).\r\n\r\n```javascript\r\nnew (function() {\r\n    var ext = this;\r\n\r\n    // Cleanup function when the extension is unloaded\r\n    ext._shutdown = function() {};\r\n\r\n    // Status reporting code\r\n    // Use this to report missing hardware, plugin or unsupported browser\r\n    ext._getStatus = function() {\r\n        return {status: 2, msg: 'Ready'};\r\n    };\r\n\r\n    ext.my_first_block = function() {\r\n        // Code that gets executed when the block is run\r\n    };\r\n\r\n    // Block and block menu descriptions\r\n    var descriptor = {\r\n        blocks: [\r\n            // Block type, block name, function name\r\n            [' ', 'my first block', 'my_first_block'],\r\n        ]\r\n    };\r\n\r\n    // Register the extension\r\n    ScratchExtensions.register('My first extension', descriptor, ext);\r\n})();\r\n```\r\n\r\n### Command blocks that wait\r\n\r\nSometimes it is necessary to have a command block that waits (e.g. if a block plays a sound, it may be a good idea to wait till the sound playback finishes). The sample extension below implements a \"random wait\" block to show how that can be done. Note the use of the ``console.log`` statement in the code - most Javascript methods, as well as [jQuery](http://jquery.com/) methods will work fine in an extension.\r\n\r\n```javascript\r\nnew (function() {\r\n    var ext = this;\r\n\r\n    // Cleanup function when the extension is unloaded\r\n    ext._shutdown = function() {};\r\n\r\n    // Status reporting code\r\n    // Use this to report missing hardware, plugin or unsupported browser\r\n    ext._getStatus = function() {\r\n        return {status: 2, msg: 'Ready'};\r\n    };\r\n\r\n    // Functions for block with type 'w' will get a callback function as the \r\n    // final argument. This should be called to indicate that the block can\r\n    // stop waiting.\r\n    ext.wait_random = function(callback) {\r\n        wait = Math.random();\r\n        console.log('Waiting for ' + wait + ' seconds');\r\n        window.setTimeout(function() {\r\n            callback();\r\n        }, wait*1000);\r\n    };\r\n\r\n    // Block and block menu descriptions\r\n    var descriptor = {\r\n        blocks: [\r\n            ['w', 'wait for random time', 'wait_random'],\r\n        ]\r\n    };\r\n\r\n    // Register the extension\r\n    ScratchExtensions.register('Random wait extension', descriptor, ext);\r\n})();\r\n```\r\n\r\n### Reporter blocks\r\n\r\nBlocks can also return values, and they are called _reporter_ blocks. The corresponding JavaScript function for a reporter block needs to return a value, as shown in the example below (note that this example also shows how to make blocks accept parameters).\r\n\r\n```javascript\r\nnew (function() {\r\n    var ext = this;\r\n\r\n    // Cleanup function when the extension is unloaded\r\n    ext._shutdown = function() {};\r\n\r\n    // Status reporting code\r\n    // Use this to report missing hardware, plugin or unsupported browser\r\n    ext._getStatus = function() {\r\n        return {status: 2, msg: 'Ready'};\r\n    };\r\n\r\n    ext.power = function(base, exponent) {\r\n        return Math.pow(base, exponent);\r\n    };\r\n\r\n    // Block and block menu descriptions\r\n    var descriptor = {\r\n        blocks: [\r\n            // Block type, block name, function name, param1 default value, param2 default value\r\n            ['r', '%n ^ %n', 'power', 2, 3],\r\n        ]\r\n    };\r\n\r\n    // Register the extension\r\n    ScratchExtensions.register('Sample extension', descriptor, ext);\r\n})();\r\n```\r\n\r\n### Reporter blocks that wait\r\n\r\nOne common use-case for reporter blocks is getting data from online web-services, where the blocks need to wait for the web-api call to complete. The following example shows how to fetch the current temperature of a city using an AJAX call to [Open Weather Map API](http://openweathermap.org/API). Note that the block type is _R_ instead of _r_ (which is for a non-blocking reporter).\r\n\r\n```javascript\r\nnew (function() {\r\n    var ext = this;\r\n\r\n    // Cleanup function when the extension is unloaded\r\n    ext._shutdown = function() {};\r\n\r\n    // Status reporting code\r\n    // Use this to report missing hardware, plugin or unsupported browser\r\n    ext._getStatus = function() {\r\n        return {status: 2, msg: 'Ready'};\r\n    };\r\n\r\n    ext.get_temp = function(location, callback) {\r\n        // Make an AJAX call to the Open Weather Maps API\r\n        $.ajax({\r\n              url: 'http://api.openweathermap.org/data/2.5/weather?q='+location+'&units=imperial',\r\n              dataType: 'jsonp',\r\n              success: function( weather_data ) {\r\n                  // Got the data - parse it and return the temperature\r\n                  temperature = weather_data['main']['temp'];\r\n                  callback(temperature);\r\n              }\r\n        });\r\n    };\r\n\r\n    // Block and block menu descriptions\r\n    var descriptor = {\r\n        blocks: [\r\n            ['R', 'current temperature in city %s', 'get_temp', 'Boston, MA'],\r\n        ]\r\n    };\r\n\r\n    // Register the extension\r\n    ScratchExtensions.register('Weather extension', descriptor, ext);\r\n})();\r\n```\r\n\r\n### Hat blocks\r\n\r\nHat blocks go on top of block stacks - examples of Scratch hat blocks include \"when green flag clicked\" or \"when this sprite clicked\". To create a hat block through an extension, the block type needs to be set to _h_, as shown in the example below.\r\n\r\n```javascript\r\nnew (function() {\r\n    var ext = this;\r\n    var alarm_went_off = false; // This becomes true after the alarm goes off\r\n\r\n    // Cleanup function when the extension is unloaded\r\n    ext._shutdown = function() {};\r\n\r\n    // Status reporting code\r\n    // Use this to report missing hardware, plugin or unsupported browser\r\n    ext._getStatus = function() {\r\n        return {status: 2, msg: 'Ready'};\r\n    };\r\n\r\n    ext.set_alarm = function(time) {\r\n       window.setTimeout(function() {\r\n           alarm_went_off = true;\r\n       }, time*1000);\r\n    };\r\n\r\n    ext.when_alarm = function() {\r\n       // Reset alarm_went_off if it is true, and return true\r\n       // otherwise, return false.\r\n       if (alarm_went_off === true) {\r\n           alarm_went_off = false;\r\n           return true;\r\n       }\r\n\r\n       return false;\r\n    };\r\n\r\n    // Block and block menu descriptions\r\n    var descriptor = {\r\n        blocks: [\r\n            ['', 'run alarm after %n seconds', 'set_alarm', '2'],\r\n            ['h', 'when alarm goes off', 'when_alarm'],\r\n        ]\r\n    };\r\n\r\n    // Register the extension\r\n    ScratchExtensions.register('Alarm extension', descriptor, ext);\r\n})();\r\n```\r\n\r\n## Hardware Support\r\n\r\nScratch provides its own set of APIs in order to allow extensions to access certain types of hardware. Currently, Scratch extensions may access the following types of hardware:\r\n- Serial devices such as the PicoBoard\r\n- USB HID devices such as joysticks or the LEGO WeDo\r\n\r\nExtensions that request hardware access are required to implement two additional methods on the extension instance: `_deviceConnected()` and `_deviceRemoved()`. Both methods receive a device instance. To use the integrated hardware functions of the Scratch Extension API you pass the hardware information in the registration call:\r\n```javascript\r\nScratchExtensions.register('Example Name', descriptor_object, ext_instance[, hardware_info]);\r\n```\r\n\r\nThe `_getStatus()` method of your extension can be used to indicate whether your extension has successfully communicated with a hardware device. For example:\r\n```javascript\r\next._getStatus = function() {\r\n    if(!device) return {status: 1, msg: 'Device not connected'};\r\n    return {status: 2, msg: 'Device connected'};\r\n}\r\n```\r\n\r\nThe value returned by `_getStatus()` corresponds to the color of the status 'light' in Scratch and indicates the general state of your extension. The `msg` property can be used to provide more specific information.\r\n\r\n| Value | Color  | Meaning   |\r\n| ----- | ------ | --------- |\r\n| 0     | red    | error     |\r\n| 1     | yellow | not ready |\r\n| 2     | green  | ready     |\r\n\r\nThe details of the `hardware_info` parameter and the `_deviceConnected()` and `_deviceRemoved()` methods are described below in sections specific to each type of device.\r\n\r\n*_API Note: The hardware API is still somewhat experimental and may change in the future. In particular, we will soon be making a change to methods that return hardware data, such as `read()` for HID devices: these methods will take a callback in instead of returning data directly. This change is necessary to improve compatibility and allow us to expand the variety of environments in which hardware extensions are available._*\r\n\r\n### USB HID Support\r\n_An example HID device extension is available [here](http://scratch.mit.edu/scratchr2/static/js/scratch_extensions/sixaxisExtension.js)._\r\n_More information about the HID protocol is available [here](http://www.usb.org/developers/devclass_docs/HID1_11.pdf)._\r\n\r\nTo let the extension system know that your extension is interested in USB HID devices, pass an object like this for the `hardware_info` parameter of the `register()` method:\r\n```javascript\r\nvar hid_info = {type: 'hid', vendor: 0x0694, product: 0x0003};\r\nScratchExtensions.register('Example', descriptor, ext, hid_info);\r\n```\r\nThe `vendor` and `product` values indicate the USB vendor and product ID of the device your extension supports. These values are frequently expressed as four-digit hexadecimal values, as indicated with the `0x` prefix in the JavaScript above.\r\n\r\nIf a device is connected with matching vendor and product IDs, Scratch will call the `_deviceConnected()` method on your extension and pass an object representing that device. Your `_deviceConnected()` method should keep track of the device object and set up communication as necessary for your needs. For example, this will start polling the device for new HID data every 20 milliseconds:\r\n```javascript\r\nvar poller = null;\r\next._deviceConnected = function(dev) {\r\n    if(device) return;\r\n\r\n    device = dev;\r\n    device.open();\r\n\r\n    poller = setInterval(function() {\r\n        rawData = device.read();\r\n    }, 20);\r\n};\r\n```\r\n\r\nOnce a connection to your device is established, your extension may use the `read()` and `write()` methods on the device object to communicate with it. These methods use [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays) objects to contain data being sent or received.\r\n* `device.read(48)` will attempt to read 48 bytes of data and return an ArrayBuffer containing any data successfully read. Note that one packet of HID data is 48 bytes. *_This method is likely to change soon. See the API Note above._*\r\n* `device.write(buffer)` will send the given ArrayBuffer's data to the device.\r\n\r\nYour extension will also be notified if a matching device is disconnected, allowing your extension a chance to stop communication:\r\n```javascript\r\next._deviceRemoved = function(dev) {\r\n    if(device != dev) return;\r\n    if(poller) poller = clearInterval(poller);\r\n    device = null;\r\n};\r\n```\r\n\r\nFinally, your extension's `_shutdown()` method will be executed when the extension itself is shut down. For example:\r\n```javascript\r\next._shutdown = function() {\r\n    if(poller) poller = clearInterval(poller);\r\n    if(device) device.close();\r\n    device = null;\r\n}\r\n```\r\n\r\n### Serial Device Support\r\n_An example serial device extension is available [here](http://scratch.mit.edu/scratchr2/static/js/scratch_extensions/picoExtension.js)._\r\n\r\nTo let the extension system know that your extension is interested in serial devices, pass an object like this for the `hardware_info` parameter of the `register()` method:\r\n```javascript\r\nvar serial_info = {type: 'serial'};\r\nScratchExtensions.register('Example', descriptor, ext, serial_info);\r\n```\r\n\r\nYour extension's `_deviceConnected()` method will be called for each serial port present on the computer. Your extension is responsible for checking if a suitable device is attached to that port and continuing on to the next port if necessary. Do not assume that the first time Scratch calls your `_deviceConnected()` will correspond to your device's serial port. The PicoBoard extension shows an example of how to deal with this situation: if no valid PicoBoard communication is received on a given port withing a particular timeout, the extension assumes that there is no PicoBoard on that port and continues scanning to the next port.\r\n```javascript\r\nvar potentialDevices = [];\r\next._deviceConnected = function(dev) {\r\n    potentialDevices.push(dev);\r\n\r\n    if (!device) {\r\n        tryNextDevice();\r\n    }\r\n}\r\n```\r\n\r\nTo communicate with a given serial port, your extension should open it with whichever options are appropriate for your device. These parameters are based on [Boost.Asio's serial port options](http://www.boost.org/doc/libs/1_50_0/doc/html/boost_asio/reference/serial_port_base.html). For a PicoBoard:\r\n```javascript\r\ndevice.open({ stopBits: 0, bitRate: 38400, ctsFlowControl: 0 });\r\n```\r\nThe full set of options available for a serial port are as follows:\r\n\r\n| Option         | Default | Valid values | Description\r\n| -------------- | ------- | ------------ | -----------\r\n| bitRate        | 9600 | Any valid baud rate | Up to  The bit (or baud) rate at which to communicate.\r\n| bufferSize     | 4096 | Up to 8192 | The maximum amount of data that can be received at a time.\r\n| ctsFlowControl | 1 (software) | 0 (none), 1 (software), 2 (hardware) | The type of flow control to use.\r\n| dataBits       | 8 | 5, 6, 7, 8 | The number of data bits per character.\r\n| parityBit      | 0 (none) | 0 (none), 1 (odd), 2 (even) | Whether and how to use the parity bit in each character.\r\n| stopBits       | 1 (1.5 bits) | 0 (1 bit), 1 (1.5 bits), 2 (2 bits) | The number of stop bits per character.\r\n\r\nOnce a connection to your device is established, your extension may use the `send()` method to send data to your device, and the `set_receive_handler()` method to register a function to handle received data. These methods use [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays) objects to contain data being sent or received.\r\n* `device.send(buffer)` will send the given ArrayBuffer's data to the device.\r\n* `device.set_receive_handler(myReceiveHandler)` will result in `myReceiveHandler(buffer)` being called any time Scratch receives data from the device. Your receive handler will be supplied an ArrayBuffer containing the received data.\r\n\r\nYour extension will also be notified if a device is disconnected, allowing your extension a chance to stop communication:\r\n```javascript\r\next._deviceRemoved = function(dev) {\r\n    if(device != dev) return;\r\n    if(poller) poller = clearInterval(poller);\r\n    device = null;\r\n};\r\n```\r\n\r\nFinally, your extension's `_shutdown()` method will be executed when the extension itself is shut down. For example:\r\n```javascript\r\next._shutdown = function() {\r\n    if(poller) poller = clearInterval(poller);\r\n    if(device) device.close();\r\n    device = null;\r\n}\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}